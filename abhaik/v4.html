<script src="https://d3js.org/d3.v7.min.js"></script>
<section id="viz-break-even-dot" style="padding:40px 0;">
  <h2>Break-Even Distance Over Time</h2>
  <p>As grids decarbonize, the EV carbon break-even distance shrinks.</p>
  <svg id="break-even-dot-chart" width="800" height="200"></svg>
</section>
<script>
function initBreakEvenDotChart() {
  const svg = d3.select("#break-even-dot-chart");
  const width = +svg.attr("width");
  const height = +svg.attr("height");
  const margin = { top: 30, right: 40, bottom: 40, left: 60 };
  const innerWidth = width - margin.left - margin.right;
  const innerHeight = height - margin.top - margin.bottom;

  const g = svg.append("g")
    .attr("transform", `translate(${margin.left},${margin.top})`);

  // Synthetic break-even distances, replace with your results
  const years = d3.range(2020, 2031);
  const breakEven = years.map((y, i) => {
    const t = i / (years.length - 1);
    const val = 100000 - 70000 * t; // 100k -> 30k
    return { year: y, break_even_km: val };
  });

  const x = d3.scaleLinear()
    .domain([0, d3.max(breakEven, d => d.break_even_km) * 1.05])
    .range([0, innerWidth]);

  const y = d3.scaleLinear()
    .domain([-1, 1])
    .range([innerHeight, 0]);

  const xAxis = d3.axisBottom(x)
    .ticks(5)
    .tickFormat(d => d/1000 + "k km");

  g.append("g")
    .attr("transform", `translate(0,${innerHeight})`)
    .call(xAxis);

  g.append("text")
    .attr("x", innerWidth / 2)
    .attr("y", innerHeight + 35)
    .attr("text-anchor", "middle")
    .text("Break-even distance (km)");

  const dot = g.append("circle")
    .attr("r", 10)
    .attr("cy", y(0))
    .attr("cx", x(breakEven[0].break_even_km))
    .attr("fill", "#1FBF74");

  const label = g.append("text")
    .attr("x", x(breakEven[0].break_even_km))
    .attr("y", y(0) - 15)
    .attr("text-anchor", "middle")
    .style("font-size", "14px")
    .text(`2020 – ${(breakEven[0].break_even_km/1000).toFixed(0)}k km`);

  let idx = 0;
  window._playBreakEvenDot = () => {
    if (window._dotInterval) return;
    function step() {
      const d = breakEven[idx % breakEven.length];
      dot
        .transition()
        .duration(800)
        .attr("cx", x(d.break_even_km));

      label
        .transition()
        .duration(800)
        .attr("x", x(d.break_even_km))
        .text(`${d.year} – ${(d.break_even_km/1000).toFixed(0)}k km`);

      idx = (idx + 1) % breakEven.length;
    }
    step();
    window._dotInterval = setInterval(step, 1600);
  };
}

// Scroll trigger
document.addEventListener("DOMContentLoaded", () => {
  initBreakEvenDotChart();

  const section = document.querySelector("#viz-break-even-dot");
  const observer = new IntersectionObserver(entries => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        if (window._playBreakEvenDot) {
          window._playBreakEvenDot();
        }
        observer.unobserve(section);
      }
    });
  }, { threshold: 0.4 });

  observer.observe(section);
});
</script>
